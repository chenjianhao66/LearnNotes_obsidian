#Shell


### 什么是Shell
Shell 是 Linux 的命令解释器，用于解释用户对操作系统的操作；Shell 会把用户所执行的命令翻译给 Linux 内核，Linux 内核将执行命令的结果反馈给用户。

比如 `ls` 命令，Shell 会分析 `ls` 命令中的选项和参数，然后将该命令交给文件管理器；文件管理器再去和硬盘打交道将返回结果，最终再反馈给用户；如果将 Shell 脚本编写好的话，用户就不用去编写驱动程序，也不用去开发 c 语言，这也就可以去控制内核，控制操作系统去实现自己想做的事情，不用去了解很多操作系统硬件相关的知识。

Shell 也有很多的版本，有C shell、K shell、TCSH、zsh、ash、bash等等，而 Linux 默认使用的 Shell 是 bash。

### Shell 脚本的格式

Shell 脚本的格式和现在的编程语言结构很相似，它们都是自上而下执行命令的；在此过程中也会用到变量去临时存储一些数据，这些命令也不一定是顺序执行的，包括了判断和分支、以及循环、定时等功能。

Shell脚本都有哪些元素构成呢？有 `Sha-Bang` 、注释、命令组成

#### Sha-Bang

脚本文件的后缀名一般是 `.sh`

当该脚本需要传给其他系统去执行，其他系统的默认 Shell 可能不是 bash，那我这个脚本能不能去执行呢？这就引出了 Shell 脚本的文件头格式，示例：

```bash
vim demo.sh

#!/bin/bash

## 你的shell 命令
```

在以上的文件中可以发现，我在脚本的文件头添加了 `#!/bin/bash` 这一行命令，这一行命令被叫做 `Sha-Bang` ，也就意味着告诉执行脚本的系统，使用什么版本的 Shell 去执行该脚本，在本文件中使用 `/bin/bash` 去执行该脚本。

如果执行该脚本使用的是 `bash demo.sh` 命令，那么该 `Sha-Bang` 就会被当作注释；如果使用 `./demo.sh` 方法去运行的话，因为不知道该系统默认的 Shell 版本，所以 `Sha-Bang` 就会被执行，告诉系统使用 `/bin/bash` 版本的 Shell 去执行该脚本。


#### 注释
在 Shell 脚本文件中，注释是以 `#` 开头的，`#` 后面跟的就是该 Shell 脚本的注释。

#### 命令
这里的命令就有包含了很多，比如判断和分支、循环、变量还有内建命令等等


### 执行 Shell 文件的方式

现在我有一个脚本文件 `demo.sh`，那这个文件该如何执行呢？有 4 种执行方式

- bash demo.sh
- ./demo.sh
- source demo.sh
- . demo.sh

这 4 种方式分别有什么区别呢？

**bash demo.sh** 和 **./demo.sh**  这两种方式很类似，这两种方式会产生一个叫做 `bash` 的子进程，在这个子进程下面再去运行该脚本。唯一的区别呢就是 **./demo.sh** 的这种方式会执行 `Sha-Bang`，而 **bash** 不用，因为这种方式就显示的指定 bash 去执行该脚本。

而后两种方式 **source demo.sh** 和 **. demo.sh** 就和前 2 种产生子进程然后执行脚本的方式不一样，这两种是在本进程下面去执行脚本文件的。

示例：
```bash
## 创建一个脚本文件，文件含义就是进入 /etc 目录下，并且打印出当前目录的路径

root@ls529hJ9gm:~# vim demo.sh

#!/bin/bash

cd /etc
pwd
## 文件结束

root@ls529hJ9gm:~#

## 下面分别以以上这 4 种方式去执行该脚本，分别看看他们的输出

## 第一种方式执行，执行后打印出了 /etc 目录当时当前进程的位置没有发生改变
root@ls529hJ9gm:~# bash ./demo.sh
/etc

## 第二种方式执行，发现没有权限，最后赋予权限后和第一种结果一样，打印出目录但是当前进程的位置没有发生改变
root@ls529hJ9gm:~# ./demo.sh
-bash: ./demo.sh: Permission denied
root@ls529hJ9gm:~# chmod u+x demo.sh
root@ls529hJ9gm:~# ./demo.sh
/etc
root@ls529hJ9gm:~#
root@ls529hJ9gm:~#

## 第三种方式，在脚本执行完之后，当前进程的位置由 ~ 目录变成了 /etc 目录
root@ls529hJ9gm:~# source ./demo.sh
/etc
root@ls529hJ9gm:/etc#
root@ls529hJ9gm:/etc# cd ~
root@ls529hJ9gm:~#

## 第四种方式与第三种方式结果一样，位置发生了改变
root@ls529hJ9gm:~# . demo.sh
/etc
root@ls529hJ9gm:/etc#
root@ls529hJ9gm:/etc#
```


### 重定向

Linux 中标准的输入设备默认指的是键盘，标准输出指的是显示器，而这里的重定向也就是对输入、输出的重定向；
-   输入重定向：指的是重新指定设备来代替键盘作为新的输入设备；
-   输出重定向：指的是重新指定设备来代替显示器作为新的输出设备。

> 通常是用文件或命令的执行结果来代替键盘作为新的输入设备，而新的输出设备通常指的就是文件。

#### 输入重定向

输入重定向所用到的符号如表所示：

| 命令符号格式           | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 命令 < 文件            | 将文件作为命令的输入                                         |
| 命令 << 分界符         | 表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串;通常分界符用的最多的是 **EOF** |
| 命令 < 文件 1 > 文件 2 | 将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。 |

示例：

默认情况下，cat 命令会接受标准输入设备（键盘）的输入，并显示到控制台，但如果用文件代替键盘作为输入设备，那么该命令会以指定的文件作为输入设备，并将文件中的内容读取并显示到控制台。

以 /etc/passwd 文件（存储了系统中所有用户的基本信息）为例，执行如下命令：

```bash
root@ls529hJ9gm:~# cat /etc/passwd
#这里省略输出信息
root@ls529hJ9gm:~# cat < /etc/passwd
#输出结果同上面命令相同
```

注意，虽然执行结果相同，但第一行代表是以键盘作为输入设备，而第二行代码是以 /etc/passwd 文件作为输入设备。



示例2：

```bash
## wc -l 命令统计用户输入数据的行数，输入完数据之后再使用 ctrl+d 结束输入
root@ls529hJ9gm:~# wc -l
11
22
2

## 上面我输入了11、22，最终统计输入了2行数据，那这里我使用输入重定向，将默认输入的键盘换到一个文件输入，也是上面的 /etc//passwd 文件
root@ls529hJ9gm:~# wc -l < /etc/passwd
29
```

最终结果与示例1相同，统计出了29行。

