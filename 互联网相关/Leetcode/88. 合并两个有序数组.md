2021-11-01
19:02:08
author:陈建浩
#leetcode  #数组 #数据结构

--- 

#### 88. 合并两个有序数组

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

**示例1：**
```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例2：**
```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

**示例3：**
```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

#### 解题思路
（1）定义一个存放结果的数组和一个指向结果数组头部的指针；
（2）使用双指针算法，定义2个指针，分别指向这两个数组的头部；
（3）使用for循环，循环的次数是这两个数组的长度之和，在遍历中依次比较指针所指向元素的大小，谁小那么就将谁放入结果数组中，并且将结果小的数组指针以及结果数组指针更新；
（4）在遍历的时候还需要处理边界问题，在两个指针小于对应数组长度的时候才能进行比较，并且是逻辑与的判断；

```java
假设 x 和 y 是指向数组的指针，m 和 n 是两个数组的长度

	if( x < m && y < n){
		//判断两个数组指针所指向元素的大小
	}
```

（5）还有一种情况出现，那就是其中一个数组已经遍历完了另外一个数组没有遍历完，按照上面判断的逻辑已经无法进行比较，那么这时候还有进行2个判断，就是对这2个指针进行单独的判断 `if ( x < m )`  和  `if( y < n )` ；
在实际环境中无法判断这2个数组谁先遍历完，所以这2个判断都写上，如果结果为true，那么就将对应指针的元素放到结果数组当中，并将指针进行更新；
（6）题目要求将结果返回到 nums1 数组中，最后遍历结果数组，将结果数组中的元素放到 Nums1 数组中，完成题目要求。

#### 代码

```java
class Solution {

	 public void merge(int[] nums1, int m, int[] nums2, int n) {

		 int result[] = new int[m+n];

		 int x = 0;

		 int y = 0;

		 int index = 0;

		 for ( int i = 0 ; i < m+n; i++){
		 		if( x < m && y < n){
		 			if( nums1[x] <= nums2[y] ){
		 				result[i] = nums1[x++];
		 			} else if (nums1[x] > nums2[y] ){
		 				result[i] = nums2[y++];
		 			}
		 		} else if ( x == m ){
		 			result[i] = nums2[y++];
		 		} else if ( y == n ){
		 			result[i] = nums1[x++];
		 		}
		 }

		 for( int a = 0; a < result.length; a++){
		 	nums1[a] = result[a];
		 }

	 }

}
```